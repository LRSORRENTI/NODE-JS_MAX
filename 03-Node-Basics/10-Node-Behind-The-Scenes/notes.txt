=========================
Node.js Behind The Scenes
=========================

==============
SINGLE THREAD
==============

ONE THING TO KEEP IN MIND IS THAT 
NODE.JS USES ONLY ONE SINGLE JS 
THREAD 

A THREAD BEING A PROCESS RUNNING ON 
YOUR OPERATING SYSTEM 

SO IF IT'S ONLY USING A SINGLE THREAD,
HOW DOES IT HANDLE MULTIPLE REQUESTS? 

IF WE CAN'T ASSIGN A NEW THREAD TO AN 
INCOMING REQUEST, THEY ALL RUN ON THE SAME 
THREAD 

LET'S GO OVER AN EXAMPLE

WE HAVE A BIT OF CODE WHICH ACCESSES THE FILE 
SYSTEM 'fs' 

WORKING WITH FILES IS OFTEN A TASK THAT 
TAKES LONGER, BECAUSE FILES CAN BE VERY LARGE
AND THAT TAKES ADDITIONAL TIME TO COMPLETE

SO IF WE'RE CURRENTLY DOING SOMETHING WITH 
'fs' AND A DIFFERENT REQUEST COMES IN, THAT 
NEW REQUEST MAY NEED TO WAIT SINCE WE'RE 
CURRENTLY HANDLING A TASK USING 'fs' 

THIS BRINGS US BACK TO THE: 

==========
EVENT LOOP
==========

THE EVENT LOOP IS AUTOMATICALLY STARTED WHEN WE START 
A PROGRAM

AND THE EVENT LOOP IS RESPONSIBLE FOR HANDLING 
EVENT CALLBACKS 

THE EVENT LOOP WILL ONLY HANDLE CALLBACKS THAT 
CAN FINISH QUICKLY 

SO OUR 'fs' OPERATION, AND OTHER LONGER TAKING 
PROCESSES ARE SENT TO THE WORKER POOL 

THE WORKER POOL IS ALSO SPUN UP AUTOMATICALLY 
BY NODE.JS 

===========
WORKER POOL
===========

THIS WORKER POOL IS WHERE ALL THE HEAVY 
LIFTING IS DONE, AND IMPORTANT 
DISTINCTION IS THAT THE WORKER POOL RUNS 
ON DIFFERENT THREAD(S), IN A SENSE IT'S 
DETACHED FROM YOUR CODE 

SO WHEN WE WORK WITH 'fs' A WORKER FROM THE 
WORKER POOL DETACHED FROM YOUR CODE WILL 
BEING DOING THE WORK ON A DIFFERENT THREAD

AND THE CONNECTION BACK TO THE EVENT LOOP 
IS THAT ONCE THE WORKER IS DONE, ONCE 
WE WRITE TO A FILE OR WHATEVER WE'RE DOING WITH 
'fs' IT WILL TRIGGER A CALLBACK, AND SINCE THE 
EVENT LOOP IS RESPONSIBLE FOR EVENTS AND 
CALLBACKS, THIS PARTICULAR WORKER POOL CALLBACK 
WILL END UP IN THE EVENT LOOP

======================
BACK TO THE EVENT LOOP
======================

THIS EVENT LOOP IN THE END IS A LOOP STARTED BY 
NODE.JS, WHICH KEEPS THE NDDE.JS PROCESS 
RUNNING, AND HANDLES CALLBACKS 

AND IT HAS AN ORDER IN WHICH IT GOES THROUGH
THE CALLBACKS

SO IT'S A LOOP THAT KEEPS ON LOOPING, AND AT 
THE BEGINNING OF EACH NEW ITERATION 
IT CHECKS IF THERE ARE ANY TIMER CALLBACKS 
IT SHOULD EXECUTE, LIKE 'setTimeout()' AND 
'setInterval()' 

SO WE CAN SET THESE TIMERS TO EXECUTE A FUNCTION 
INSIDE THESE CALLBACKS ONCE THE TIMER COMPLETES 

NODE.JS IS AWARE OF THIS, AND ON EACH NEW ITERATION 
OF THE EVENT LOOP IT WILL EXECUTE ANY TIMER 
CALLBACKS THAT ARE DUE FOR EXECUTION 

THEN IT CHECKS THE PENDING CALLBACKS, CALLBACKS 
THAT MAY HAVE NEEDED MORE TIME TO FINISH AND 
ARE NOW READY TO EXECUTE 

THIS INCLUDES I/O OR INPUT / OUTPUT, 
DISK AND NETWORK OPERATIONS 
(~BLOCKING OPERATIONS) LONG TIME TO COMPLETE 
OPERATIONS

AFTER HOPEFULLY FINISHING ALL THE DUE CALLBACKS 
NODE ENTERS A 'POLL' PHASE, A PHASE WHERE NODE 
WILL LOOK FOR NEW I/O EVENTS AND WILL TRY TO 
EXECUTE THOSE CALLBACKS IF POSSIBLE

IF IT CANNOT BE EXECUTED IT WILL REGISTER IT 
AS A PENDING CALLBACK

IT ALSO CHECKS FOR THE TIMER CALLBACKS DUE, AND 
IT WILL THEN JUMP TO THOSE AND EXECUTE THEM 

NEXT IS THE 'CHECK' PHASE WHERE NODE WILL EXECUTE 
'setImmediate()' 
 
'setImmediate()'  IS USED TO EXECUTE A GIVEN CALLBACK 
FUNCTION IMMEDIATELY AFTER THE CURRENT ITERATION 
OF THE EVENT LOOP, BUT BEFORE ANY TIMERS OR INPUT/
OUTPUT I/O OPERATIONS ARE SCHEDULED 


NOW WE'RE NEAR THE END OF THE EVENT LOOP CYCLE AND 
NODE WILL EXECUTE ANY 'close' events 

The 'close' event is emitted 
by certain types of Node.js streams 
when the underlying resource 
(such as a file descriptor 
or network socket) has been closed.

A 'close' event callback 
is a function that is
 executed when this event 
 is emitted. You can register 
 a 'close' event callback using 
 the on() method of the stream object.

For example, if you're 
working with a file stream,
 you can register a 'close' 
 event callback like this:

 const fs = require('fs');

const stream = fs.createReadStream('example.txt');

stream.on('close', () => {
  console.log('The stream has been closed');
});

This code creates a file stream for
 the file example.txt, and registers a 
 'close' event callback that simply 
 logs a message to the console.

When the stream is closed
 (either by calling stream.close()
  or by reaching the end of the file), 
  the 'close' event will be emitted,
   and the callback function will be executed.

You can use 'close' event 
callbacks to perform cleanup
 tasks or other actions that 
 need to be taken when a stream is closed.

 SO THE CYCLE LOOKS LIKE: 

 TIMERS --> PENDING CALLBACKS --> 
 POLL --> CHECK --> CLOSE --> TIMERS ..... 

 

